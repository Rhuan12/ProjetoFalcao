import streamlit as st
import PyPDF2
import pandas as pd
import re
import os
from io import BytesIO
import tempfile
import numpy as np

# Importa√ß√µes condicionais para OCR
OCR_AVAILABLE = False
try:
    import easyocr
    from pdf2image import convert_from_path
    from PIL import Image
    OCR_AVAILABLE = True
except ImportError:
    st.warning("‚ö†Ô∏è OCR n√£o dispon√≠vel. Apenas PDFs com texto ser√£o processados.")

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Conversor de Ap√≥lices Tokio Marine",
    page_icon="üìÑ",
    layout="wide"
)

@st.cache_resource
def load_easyocr():
    """Carrega o modelo EasyOCR (cache para n√£o recarregar sempre)"""
    if OCR_AVAILABLE:
        try:
            reader = easyocr.Reader(['pt', 'en'], gpu=False)
            return reader
        except Exception as e:
            st.error(f"Erro ao carregar EasyOCR: {e}")
            return None
    return None

def extract_text_from_pdf(pdf_file):
    """
    Extrai texto de um arquivo PDF usando PyPDF2 e EasyOCR como fallback
    """
    try:
        # Cria um arquivo tempor√°rio
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
            tmp_file.write(pdf_file.read())
            tmp_file_path = tmp_file.name
        
        text = ""
        
        # Tentativa 1: Extrair texto diretamente com PyPDF2
        st.info("üîç Tentando extrair texto diretamente do PDF...")
        try:
            with open(tmp_file_path, "rb") as file:
                reader = PyPDF2.PdfReader(file)
                for page_num, page in enumerate(reader.pages):
                    page_text = page.extract_text()
                    if page_text.strip():
                        text += page_text + "\n"
                        
            if text.strip():
                st.success("‚úÖ Texto extra√≠do diretamente do PDF!")
        except Exception as e:
            st.warning(f"PyPDF2 falhou: {e}")
        
        # Tentativa 2: Se n√£o conseguiu extrair texto, usar EasyOCR
        if not text.strip() and OCR_AVAILABLE:
            st.info("üì∏ PDF parece ser uma imagem. Usando EasyOCR para extrair texto...")
            
            # Carrega o modelo EasyOCR
            reader = load_easyocr()
            if reader is None:
                st.error("‚ùå N√£o foi poss√≠vel carregar o EasyOCR")
                return ""
            
            # Progresso para OCR
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            try:
                # Converte PDF para imagens
                status_text.text("Convertendo PDF para imagens...")
                images = convert_from_path(tmp_file_path, dpi=300)
                
                total_pages = len(images)
                status_text.text(f"Processando {total_pages} p√°gina(s) com EasyOCR...")
                
                all_text = []
                
                for i, img in enumerate(images):
                    # Atualiza progresso
                    progress = (i + 1) / total_pages
                    progress_bar.progress(progress)
                    status_text.text(f"Processando p√°gina {i+1} de {total_pages}...")
                    
                    # Converte PIL Image para numpy array
                    img_array = np.array(img)
                    
                    # Aplica EasyOCR na imagem
                    results = reader.readtext(img_array)
                    
                    # Extrai o texto dos resultados
                    page_text = []
                    for (bbox, text_detected, confidence) in results:
                        if confidence > 0.5:  # Filtro de confian√ßa
                            page_text.append(text_detected)
                    
                    # Junta o texto da p√°gina
                    if page_text:
                        all_text.append(' '.join(page_text))
                
                # Junta todo o texto
                text = '\n'.join(all_text)
                
                progress_bar.progress(1.0)
                status_text.text("‚úÖ EasyOCR conclu√≠do!")
                
                # Limpa os elementos de progresso
                import time
                time.sleep(1)
                progress_bar.empty()
                status_text.empty()
                
                if text.strip():
                    st.success("‚úÖ Texto extra√≠do com EasyOCR!")
                else:
                    st.warning("‚ö†Ô∏è EasyOCR n√£o conseguiu extrair texto leg√≠vel")
                
            except Exception as ocr_error:
                st.error(f"Erro no EasyOCR: {ocr_error}")
                progress_bar.empty()
                status_text.empty()
        
        elif not text.strip():
            st.error("‚ùå PDF √© uma imagem, mas EasyOCR n√£o est√° dispon√≠vel.")
            st.markdown("""
            **Para usar EasyOCR:**
            ```bash
            pip install easyocr pdf2image Pillow
            ```
            """)
        
        # Remove o arquivo tempor√°rio
        os.unlink(tmp_file_path)
        
        return text
        
    except Exception as e:
        st.error(f"Erro geral ao processar PDF: {e}")
        return ""

def extract_field(patterns, text):
    """
    Procura por uma lista de padr√µes regex e retorna o valor encontrado
    """
    for pattern in patterns:
        match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        if match:
            value = match.group(1).strip()
            # Remove quebras de linha e espa√ßos extras
            value = re.sub(r'\s+', ' ', value)
            return value
    return "N√£o encontrado"

def parse_tokio_data(text):
    """
    Extrai dados espec√≠ficos da ap√≥lice Tokio Marine
    """
    # Limpa o texto para melhor parsing
    text = re.sub(r'\s+', ' ', text)
    
    # Dados do cabe√ßalho/cliente
    dados_header = {
        "NOME DO CLIENTE": extract_field([
            r"Propriet√°rio[:\s]*([^:\n]*?)(?=\s*(?:Tipo|CEP|Fabricante|$))",
            r"ROD TRANSPORTES LTDA",
            r"([A-Z\s]{10,}(?:LTDA|S\.A\.|EIRELI))"
        ], text),
        "CNPJ": extract_field([
            r"CNPJ[:\s]*([^:\n]*?)(?=\s*(?:Tipo|CEP|Fabricante|$))",
            r"(\d{2}\.?\d{3}\.?\d{3}/?\d{4}-?\d{2})"
        ], text),
        "AP√ìLICE": extract_field([
            r"(?:Nr\s*)?Ap√≥lice[:\s]*([^:\n]*?)(?=\s*(?:Venc|Tipo|CEP|$))",
            r"(\d{8,})"
        ], text),
        "VIG√äNCIA": extract_field([
            r"Venc[^:]*Ap√≥lice[^:]*[:\s]*([^:\n]*?)(?=\s*(?:Tipo|CEP|$))",
            r"(\d{2}/\d{2}/\d{4})"
        ], text),
    }

    # Dados do ve√≠culo
    dados_veiculo = {
        "DESCRI√á√ÉO DO ITEM": extract_field([
            r"Descri√ß√£o do Item[^:]*[:\s-]*([^:\n]*?)(?=\s*(?:CEP|Tipo|Fabricante|$))",
            r"(Produto Auto Frota)",
            r"(\d+\s*-\s*Produto Auto Frota)"
        ], text),
        "CEP DE PERNOITE DO VE√çCULO": extract_field([
            r"CEP de Pernoite do Ve√≠culo[:\s]*([^:\n]*?)(?=\s*(?:Tipo|Fabricante|$))",
            r"(\d{5}-?\d{3})"
        ], text),
        "TIPO DE UTILIZA√á√ÉO": extract_field([
            r"Tipo de utiliza√ß√£o[:\s]*([^:\n]*?)(?=\s*(?:Ano|Fabricante|$))",
            r"(Particular/?Comercial)"
        ], text),
        "FABRICANTE": extract_field([
            r"Fabricante[:\s]*([^:\n]*?)(?=\s*(?:Ve√≠culo|Ano|$))",
            r"(CHEVROLET|FORD|VOLKSWAGEN|FIAT|[A-Z]{3,})"
        ], text),
        "VE√çCULO": extract_field([
            r"Ve√≠culo[:\s]*([^:\n]*?)(?=\s*(?:Ano|4¬∫|$))",
            r"(S10 PICK-UP LTZ[^:\n]*)"
        ], text),
        "ANO MODELO": extract_field([
            r"Ano Modelo[:\s]*([^:\n]*?)(?=\s*(?:Chassi|4¬∫|$))",
            r"(\d{4})"
        ], text),
        "CHASSI": extract_field([
            r"(?:^|\s)Chassi[:\s]*([^:\n]*?)(?=\s*(?:Chassi Remarcado|Placa|$))",
            r"([A-Z0-9]{17})"
        ], text),
        "CHASSI REMARCADO": extract_field([
            r"Chassi Remarcado[:\s]*([^:\n]*?)(?=\s*(?:Combust√≠vel|Placa|$))"
        ], text),
        "PLACA": extract_field([
            r"Placa[:\s]*([^:\n]*?)(?=\s*(?:Lota√ß√£o|Combust√≠vel|$))",
            r"([A-Z]{3}\d{4}|[A-Z]{3}\d[A-Z]\d{2})"
        ], text),
        "COMBUST√çVEL": extract_field([
            r"Combust√≠vel[:\s]*([^:\n]*?)(?=\s*(?:Lota√ß√£o|Ve√≠culo|$))",
            r"(Diesel|Gasolina|Flex|√Ålcool)"
        ], text),
        "LOTA√á√ÉO VE√çCULO": extract_field([
            r"Lota√ß√£o Ve√≠culo[:\s]*([^:\n]*?)(?=\s*(?:Ve√≠culo|Dispositivo|$))",
            r"(\d+)"
        ], text),
        "VE√çCULO 0KM": extract_field([
            r"Ve√≠culo 0km[:\s]*([^:\n]*?)(?=\s*(?:Ve√≠culo|Dispositivo|$))"
        ], text),
        "VE√çCULO BLINDADO": extract_field([
            r"Ve√≠culo Blindado[:\s]*([^:\n]*?)(?=\s*(?:Dispositivo|Isen√ß√£o|$))"
        ], text),
        "VE√çCULO COM KIT G√ÅS": extract_field([
            r"Ve√≠culo com Kit G√°s[:\s]*([^:\n]*?)(?=\s*(?:Tipo|Isen√ß√£o|$))"
        ], text),
        "TIPO DE CARROCERIA": extract_field([
            r"Tipo de Carroceria[:\s]*([^:\n]*?)(?=\s*(?:4¬∫|Cabine|$))"
        ], text),
        "4¬∫ EIXO ADAPTADO": extract_field([
            r"4¬∫ Eixo Adaptado[:\s]*([^:\n]*?)(?=\s*(?:Cabine|Dispositivo|$))"
        ], text),
        "CABINE SUPLEMENTAR": extract_field([
            r"Cabine Suplementar[:\s]*([^:\n]*?)(?=\s*(?:Dispositivo|Isen√ß√£o|$))"
        ], text),
        "DISPOSITIVO EM COMODATO": extract_field([
            r"Dispositivo em Comodato[:\s]*([^:\n]*?)(?=\s*(?:Isen√ß√£o|Fipe|$))"
        ], text),
        "ISEN√á√ÉO FISCAL": extract_field([
            r"Isen√ß√£o Fiscal[:\s]*([^:\n]*?)(?=\s*(?:Fipe|Propriet√°rio|$))"
        ], text),
        "PROPRIET√ÅRIO": extract_field([
            r"Propriet√°rio[:\s]*([^:\n]*?)(?=\s*(?:Fipe|Tipo|$))",
            r"(ROD TRANSPORTES LTDA)"
        ], text),
        "FIPE": extract_field([
            r"Fipe[:\s]*([^:\n]*?)(?=\s*(?:Nr|Nome|$))",
            r"(\d{6}-\d)"
        ], text),
        "TIPO DE SEGURO": "Renova√ß√£o Tokio sem sinistro",
        "NR AP√ìLICE CONGENERE": extract_field([
            r"Nr Ap√≥lice Congenere[:\s]*([^:\n]*?)(?=\s*(?:Nome|Venc|$))",
            r"(\d{8,})"
        ], text),
        "NOME DA CONGENERE": extract_field([
            r"Nome da Congenere[:\s]*([^:\n]*?)(?=\s*(?:Venc|$))",
            r"(TOKIO MARINE[^:\n]*)"
        ], text),
        "VENC AP√ìLICE CONGENERE": extract_field([
            r"Venc Ap√≥lice Cong[^:]*[:\s]*([^:\n]*?)(?=\s*$)",
            r"(\d{2}/\d{2}/\d{4})"
        ], text),
    }

    return dados_header, dados_veiculo

def create_excel_file(dados_header, dados_veiculo):
    """
    Cria arquivo Excel com os dados extra√≠dos
    """
    buffer = BytesIO()
    
    with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
        # Aba com dados gerais
        df_header = pd.DataFrame([dados_header])
        df_header.to_excel(writer, sheet_name='Dados Gerais', index=False)
        
        # Aba com dados do ve√≠culo
        df_veiculo = pd.DataFrame([dados_veiculo])
        df_veiculo.to_excel(writer, sheet_name='Ve√≠culos', index=False)
    
    buffer.seek(0)
    return buffer

def main():
    st.title("üöó Conversor de Ap√≥lices Tokio Marine")
    st.markdown("---")
    
    # Status do OCR
    if OCR_AVAILABLE:
        st.success("‚úÖ EasyOCR dispon√≠vel - Suporte completo a PDFs escaneados!")
    else:
        st.warning("‚ö†Ô∏è EasyOCR n√£o dispon√≠vel - Apenas PDFs com texto nativo")
    
    st.markdown("""
    ### Como usar:
    1. üì§ Fa√ßa o upload da sua ap√≥lice em PDF (texto ou imagem)
    2. ‚ö° Aguarde o processamento autom√°tico
    3. üëÄ Visualize os dados extra√≠dos
    4. üíæ Baixe a planilha Excel gerada
    
    **‚ú® Powered by EasyOCR - Melhor precis√£o em PDFs escaneados!**
    """)
    
    # Upload do arquivo
    uploaded_file = st.file_uploader(
        "Escolha um arquivo PDF da ap√≥lice Tokio Marine",
        type=['pdf'],
        help="Suporte completo a PDFs com texto nativo e escaneados"
    )
    
    if uploaded_file is not None:
        # Mostra informa√ß√µes do arquivo
        st.success(f"‚úÖ Arquivo carregado: {uploaded_file.name}")
        st.info(f"üìä Tamanho: {len(uploaded_file.getvalue())/1024:.1f} KB")
        
        # Bot√£o para processar
        if st.button("üîÑ Processar PDF", type="primary"):
            # Extrai texto do PDF
            text = extract_text_from_pdf(uploaded_file)
            
            if text.strip():
                # Parse dos dados
                with st.spinner("üß† Analisando dados da ap√≥lice..."):
                    dados_header, dados_veiculo = parse_tokio_data(text)
                
                # Mostra os dados extra√≠dos
                st.markdown("## üìã Dados Extra√≠dos")
                
                # Contador de campos encontrados
                encontrados_header = sum(1 for v in dados_header.values() if v != "N√£o encontrado")
                encontrados_veiculo = sum(1 for v in dados_veiculo.values() if v != "N√£o encontrado")
                total_campos = len(dados_header) + len(dados_veiculo)
                total_encontrados = encontrados_header + encontrados_veiculo
                
                st.info(f"üìä **{total_encontrados}/{total_campos}** campos extra√≠dos com sucesso ({(total_encontrados/total_campos)*100:.1f}%)")
                
                # Dados gerais em duas colunas
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown("### üè¢ Informa√ß√µes do Cliente")
                    for key, value in dados_header.items():
                        if value != "N√£o encontrado":
                            st.success(f"**{key}:** {value}")
                        else:
                            st.warning(f"**{key}:** {value}")
                
                with col2:
                    st.markdown("### üöô Informa√ß√µes do Ve√≠culo")
                    # Mostra apenas os campos mais importantes primeiro
                    campos_importantes = [
                        "FABRICANTE", "VE√çCULO", "ANO MODELO", "PLACA", 
                        "CHASSI", "COMBUST√çVEL", "FIPE", "PROPRIET√ÅRIO"
                    ]
                    for campo in campos_importantes:
                        if campo in dados_veiculo:
                            value = dados_veiculo[campo]
                            if value != "N√£o encontrado":
                                st.success(f"**{campo}:** {value}")
                            else:
                                st.warning(f"**{campo}:** {value}")
                
                # Tabelas expandidas
                with st.expander("üìä Ver todos os dados em tabela"):
                    st.markdown("#### Dados Gerais")
                    st.dataframe(pd.DataFrame([dados_header]), use_container_width=True)
                    
                    st.markdown("#### Dados do Ve√≠culo")
                    st.dataframe(pd.DataFrame([dados_veiculo]), use_container_width=True)
                
                # Gera o arquivo Excel
                excel_buffer = create_excel_file(dados_header, dados_veiculo)
                
                # Bot√£o de download
                st.markdown("## üíæ Download")
                apolice_numero = dados_header.get('AP√ìLICE', 'sem_numero')
                if apolice_numero == "N√£o encontrado":
                    apolice_numero = "sem_numero"
                nome_arquivo = f"apolice_{apolice_numero}.xlsx"
                
                st.download_button(
                    label="üì• Baixar Planilha Excel",
                    data=excel_buffer,
                    file_name=nome_arquivo,
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    type="primary"
                )
                
                st.balloons()  # Anima√ß√£o de sucesso
                st.success("‚úÖ Processamento conclu√≠do com sucesso!")
                
            else:
                st.error("‚ùå N√£o foi poss√≠vel extrair texto do PDF.")
        
        # Mostra preview do texto extra√≠do (opcional)
        with st.expander("üîç Ver texto extra√≠do do PDF (debug)"):
            if st.button("Extrair texto para visualiza√ß√£o"):
                with st.spinner("Extraindo texto..."):
                    text_preview = extract_text_from_pdf(uploaded_file)
                if text_preview:
                    st.text_area(
                        "Texto extra√≠do:", 
                        text_preview[:3000] + "..." if len(text_preview) > 3000 else text_preview, 
                        height=400
                    )
                    st.info(f"üìè Total de caracteres: {len(text_preview)}")
                else:
                    st.error("N√£o foi poss√≠vel extrair texto do PDF")

    # Informa√ß√µes adicionais
    with st.sidebar:
        st.markdown("## ‚ÑπÔ∏è Status do Sistema")
        
        # Verifica√ß√µes de depend√™ncias
        st.markdown("**Depend√™ncias:**")
        st.success("‚úÖ PyPDF2")
        st.success("‚úÖ Pandas")
        
        if OCR_AVAILABLE:
            st.success("‚úÖ EasyOCR")
            st.success("‚úÖ pdf2image")
            st.success("‚úÖ Pillow")
        else:
            st.error("‚ùå Depend√™ncias OCR")
        
        st.markdown("## üéØ Recursos")
        st.markdown("""
        **Sempre dispon√≠vel:**
        - üìÑ PDFs com texto nativo
        - üìä Export para Excel
        - üîç Modo debug
        
        **Com EasyOCR:**
        - üì∏ PDFs escaneados
        - üáßüá∑ Reconhecimento PT/EN
        - üéØ Alta precis√£o
        - ‚òÅÔ∏è Funciona na nuvem
        """)
        
        if not OCR_AVAILABLE:
            st.markdown("## üõ†Ô∏è Para habilitar OCR")
            st.code("""
pip install easyocr pdf2image Pillow
            """)
            st.markdown("**EasyOCR √© muito melhor que Tesseract para deploy na nuvem!**")
        
        st.markdown("## üìà Vantagens do EasyOCR")
        st.markdown("""
        - ‚úÖ Instala√ß√£o mais simples
        - ‚úÖ Melhor precis√£o
        - ‚úÖ Funciona no Streamlit Cloud
        - ‚úÖ Suporte a m√∫ltiplos idiomas
        - ‚úÖ N√£o requer configura√ß√£o externa
        """)

if __name__ == "__main__":
    main()