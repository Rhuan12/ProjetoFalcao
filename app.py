import streamlit as st
import PyPDF2
import pandas as pd
import re
import os
from io import BytesIO
import tempfile
import numpy as np

# Importa√ß√µes condicionais para OCR
OCR_AVAILABLE = False
TESSERACT_AVAILABLE = False

try:
    import pytesseract
    from pdf2image import convert_from_path
    from PIL import Image
    TESSERACT_AVAILABLE = True
    OCR_AVAILABLE = True
except ImportError:
    try:
        import easyocr
        from pdf2image import convert_from_path
        from PIL import Image
        import numpy as np
        OCR_AVAILABLE = True
    except ImportError:
        pass

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Conversor de Ap√≥lices Tokio Marine",
    page_icon="üìÑ",
    layout="wide"
)

@st.cache_resource
def load_easyocr():
    """Carrega o modelo EasyOCR apenas se necess√°rio"""
    if not TESSERACT_AVAILABLE and OCR_AVAILABLE:
        try:
            import easyocr
            reader = easyocr.Reader(['pt'], gpu=False, verbose=False)
            return reader
        except Exception as e:
            st.error(f"Erro ao carregar EasyOCR: {e}")
            return None
    return None

def extract_text_from_pdf(pdf_file):
    """Extrai texto de um arquivo PDF usando PyPDF2 e OCR como fallback"""
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
            tmp_file.write(pdf_file.read())
            tmp_file_path = tmp_file.name
        
        text = ""
        
        # Tentativa 1: Extrair texto diretamente com PyPDF2
        st.info("üîç Tentando extrair texto diretamente do PDF...")
        try:
            with open(tmp_file_path, "rb") as file:
                reader = PyPDF2.PdfReader(file)
                for page_num, page in enumerate(reader.pages):
                    page_text = page.extract_text()
                    if page_text.strip():
                        text += page_text + "\n"
                        
            if text.strip():
                st.success("‚úÖ Texto extra√≠do diretamente do PDF!")
        except Exception as e:
            st.warning(f"PyPDF2 falhou: {e}")
        
        # Tentativa 2: OCR apenas se necess√°rio
        if not text.strip() and OCR_AVAILABLE:
            if TESSERACT_AVAILABLE:
                st.info("üì∏ PDF √© imagem. Usando Tesseract OCR...")
                try:
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    
                    status_text.text("Convertendo PDF para imagens...")
                    images = convert_from_path(tmp_file_path, dpi=200)
                    
                    total_pages = len(images)
                    all_text = []
                    
                    for i, img in enumerate(images):
                        progress = (i + 1) / total_pages
                        progress_bar.progress(progress)
                        status_text.text(f"OCR p√°gina {i+1} de {total_pages}...")
                        
                        page_text = pytesseract.image_to_string(img, lang='por')
                        if page_text.strip():
                            all_text.append(page_text)
                    
                    text = '\n'.join(all_text)
                    progress_bar.progress(1.0)
                    status_text.text("‚úÖ Tesseract OCR conclu√≠do!")
                    
                    import time
                    time.sleep(1)
                    progress_bar.empty()
                    status_text.empty()
                    
                except Exception as tesseract_error:
                    st.warning(f"Tesseract falhou: {tesseract_error}")
                    text = ""
            
            if not text.strip() and not TESSERACT_AVAILABLE:
                st.warning("‚ö†Ô∏è Usando EasyOCR - Pode demorar no primeiro uso...")
                
                download_warning = st.warning("üì• EasyOCR est√° baixando modelos. Isso pode demorar alguns minutos na primeira vez...")
                
                reader = load_easyocr()
                if reader:
                    try:
                        download_warning.empty()
                        
                        progress_bar = st.progress(0)
                        status_text = st.empty()
                        
                        status_text.text("Convertendo PDF para imagens...")
                        images = convert_from_path(tmp_file_path, dpi=200)
                        
                        total_pages = len(images)
                        all_text = []
                        
                        for i, img in enumerate(images):
                            progress = (i + 1) / total_pages
                            progress_bar.progress(progress)
                            status_text.text(f"EasyOCR p√°gina {i+1} de {total_pages}...")
                            
                            img_array = np.array(img)
                            results = reader.readtext(img_array)
                            
                            page_text = []
                            for (bbox, text_detected, confidence) in results:
                                if confidence > 0.6:
                                    page_text.append(text_detected)
                            
                            if page_text:
                                all_text.append(' '.join(page_text))
                        
                        text = '\n'.join(all_text)
                        progress_bar.progress(1.0)
                        status_text.text("‚úÖ EasyOCR conclu√≠do!")
                        
                        import time
                        time.sleep(1)
                        progress_bar.empty()
                        status_text.empty()
                        
                    except Exception as easyocr_error:
                        st.error(f"EasyOCR falhou: {easyocr_error}")
                        download_warning.empty()
        
        os.unlink(tmp_file_path)
        return text
        
    except Exception as e:
        st.error(f"Erro geral ao processar PDF: {e}")
        return ""

def extract_field(patterns, text):
    """Procura por uma lista de padr√µes regex e retorna o valor encontrado"""
    for pattern in patterns:
        match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        if match:
            if match.groups():
                value = match.group(1).strip()
                value = re.sub(r'\s+', ' ', value)
                return value
            else:
                value = match.group(0).strip()
                value = re.sub(r'\s+', ' ', value)
                return value
    return ""

def extract_vehicle_sections(text):
    """Extrai todas as se√ß√µes de ve√≠culos do texto - vers√£o robusta"""
    vehicles = []
    
    # Debug: vamos ver o que temos no texto
    st.info("üîç Procurando se√ß√µes de ve√≠culos no texto...")
    
    # Estrat√©gia 1: Padr√µes mais flex√≠veis para "Descri√ß√£o do Item"
    patterns_descricao = [
        r'Descri√ß√£o do Item\s*-\s*(\d+)\s*-\s*Produto Auto Frota(.*?)(?=Descri√ß√£o do Item\s*-\s*\d+\s*-\s*Produto Auto Frota|Assist√™ncia 24 Horas|\Z)',
        r'Descri√ß√£o do Item\s*-\s*-\s*Produto Auto Frota(.*?)(?=Descri√ß√£o do Item\s*-\s*[\d\s]*-\s*Produto Auto Frota|Assist√™ncia 24 Horas|\Z)',
        r'Item\s*-\s*(\d+)\s*-\s*Produto Auto Frota(.*?)(?=Item\s*-\s*\d+\s*-\s*Produto Auto Frota|Assist√™ncia 24 Horas|\Z)'
    ]
    
    for i, pattern in enumerate(patterns_descricao):
        sections = re.findall(pattern, text, re.DOTALL | re.IGNORECASE)
        
        if sections:
            st.success(f"‚úÖ Encontradas {len(sections)} se√ß√µes com padr√£o {i+1}")
            for j, section in enumerate(sections):
                if len(section) == 2 and section[0]:  # Pattern com n√∫mero
                    item_num, content = section
                    vehicles.append({
                        'item': item_num.strip(),
                        'content': content.strip()
                    })
                elif len(section) == 2:  # Pattern sem n√∫mero v√°lido
                    content = section[1] if section[1] else section[0]
                    vehicles.append({
                        'item': str(j + 1),
                        'content': content.strip()
                    })
                else:  # Apenas conte√∫do
                    content = section if isinstance(section, str) else section[0]
                    vehicles.append({
                        'item': str(j + 1),
                        'content': content.strip()
                    })
            break
    
    # Estrat√©gia 2: Se n√£o encontrou, procura por CEPs (indicativos de novos ve√≠culos)
    if not vehicles:
        st.info("üîç Tentativa 2: Procurando por CEPs de pernoite...")
        cep_pattern = r'CEP de Pernoite do Ve√≠culo[:\s]*(\d{5}-?\d{3})(.*?)(?=CEP de Pernoite do Ve√≠culo|\Z)'
        cep_sections = re.findall(cep_pattern, text, re.DOTALL | re.IGNORECASE)
        
        if cep_sections:
            st.success(f"‚úÖ Encontradas {len(cep_sections)} se√ß√µes por CEP")
            for i, (cep, content) in enumerate(cep_sections):
                vehicles.append({
                    'item': str(i + 1),
                    'content': f"CEP de Pernoite do Ve√≠culo: {cep} {content}".strip()
                })
    
    # Estrat√©gia 3: Procura por fabricantes como delimitadores
    if not vehicles:
        st.info("üîç Tentativa 3: Procurando por fabricantes...")
        fabricantes = ['CHEVROLET', 'FORD', 'VOLKSWAGEN', 'FIAT', 'NISSAN', 'TOYOTA', 'BYD', 'MITSUBISHI']
        fabricante_pattern = r'Fabricante[:\s]*(' + '|'.join(fabricantes) + r')(.*?)(?=Fabricante[:\s]*(?:' + '|'.join(fabricantes) + r')|\Z)'
        
        fab_sections = re.findall(fabricante_pattern, text, re.DOTALL | re.IGNORECASE)
        
        if fab_sections:
            st.success(f"‚úÖ Encontradas {len(fab_sections)} se√ß√µes por fabricante")
            for i, (fabricante, content) in enumerate(fab_sections):
                vehicles.append({
                    'item': str(i + 1),
                    'content': f"Fabricante: {fabricante} {content}".strip()
                })
    
    # Estrat√©gia 4: Procura por placas (√∫ltimo recurso)
    if not vehicles:
        st.info("üîç Tentativa 4: Procurando por padr√µes de placas...")
        placa_pattern = r'Placa[:\s]*([A-Z]{3}\d{4}|[A-Z]{3}\d[A-Z]\d{2})(.*?)(?=Placa[:\s]*[A-Z]{3}[\dA-Z]|\Z)'
        
        placa_sections = re.findall(placa_pattern, text, re.DOTALL | re.IGNORECASE)
        
        if placa_sections:
            st.success(f"‚úÖ Encontradas {len(placa_sections)} se√ß√µes por placa")
            for i, (placa, content) in enumerate(placa_sections):
                vehicles.append({
                    'item': str(i + 1),
                    'content': f"Placa: {placa} {content}".strip()
                })
    
    if not vehicles:
        st.warning("‚ö†Ô∏è Nenhuma se√ß√£o de ve√≠culo encontrada com os padr√µes conhecidos.")
        
        # Debug: mostra parte do texto para an√°lise
        st.text_area("üìù Amostra do texto para debug:", text[:2000], height=200)
    
    return vehicles

def parse_vehicle_data(vehicle_content, item_num):
    """Extrai dados de um ve√≠culo espec√≠fico"""
    
    def extract_money(patterns, text):
        """Extrai valores monet√°rios"""
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
            if match:
                value = match.group(1).replace('.', '').replace(',', '.')
                try:
                    return float(value)
                except:
                    return value
        return ""
    
    def extract_simple(patterns, text):
        """Extrai valores simples"""
        result = extract_field(patterns, text)
        return result if result else ""
    
    dados = {
        # Identifica√ß√£o B√°sica
        'Item': item_num,
        'CEP de Pernoite': extract_simple([
            r'CEP de Pernoite do Ve√≠culo[:\s]*([^\s\n\r]+)',
            r'(\d{5}-?\d{3})'
        ], vehicle_content),
        
        'Fabricante': extract_simple([
            r'Fabricante[:\s]*([^\n\r]+?)(?=\s*Ve√≠culo[:\s]|$)',
            r'(CHEVROLET|FORD|VOLKSWAGEN|FIAT|NISSAN|TOYOTA|BYD|MITSUBISHI)'
        ], vehicle_content),
        
        'Ve√≠culo': extract_simple([
            r'Ve√≠culo[:\s]*([^\n\r]+?)(?=\s*(?:Ano Modelo|4¬∫ Eixo)|$)'
        ], vehicle_content),
        
        'Ano Modelo': extract_simple([
            r'Ano Modelo[:\s]*(\d{4})'
        ], vehicle_content),
        
        'Chassi': extract_simple([
            r'Chassi[:\s]*([A-Z0-9]{17})',
            r'Chassi[:\s]*([A-Z0-9]+)'
        ], vehicle_content),
        
        'Chassi Remarcado': extract_simple([
            r'Chassi Remarcado[:\s]*([^\n\r]+?)(?=\s*Placa[:\s]|$)'
        ], vehicle_content),
        
        'Placa': extract_simple([
            r'Placa[:\s]*([A-Z0-9]+)'
        ], vehicle_content),
        
        'Combust√≠vel': extract_simple([
            r'Combust√≠vel[:\s]*([^\n\r]+?)(?=\s*Lota√ß√£o|$)',
            r'(Diesel|Gasolina|Flex|√Ålcool|El√©trico)'
        ], vehicle_content),
        
        'Lota√ß√£o Ve√≠culo': extract_simple([
            r'Lota√ß√£o Ve√≠culo[:\s]*(\d+)'
        ], vehicle_content),
        
        'Ve√≠culo 0km': extract_simple([
            r'Ve√≠culo 0km[:\s]*([^\n\r]+?)(?=\s*Ve√≠culo Blindado|$)'
        ], vehicle_content),
        
        'Ve√≠culo Blindado': extract_simple([
            r'Ve√≠culo Blindado[:\s]*([^\n\r]+?)(?=\s*Ve√≠culo com Kit|$)'
        ], vehicle_content),
        
        'Ve√≠culo com Kit G√°s': extract_simple([
            r'Ve√≠culo com Kit G√°s[:\s]*([^\n\r]+?)(?=\s*Dispositivo|$)'
        ], vehicle_content),
        
        'Dispositivo em Comodato': extract_simple([
            r'Dispositivo em Comodato[:\s]*([^\n\r]+?)(?=\s*Tipo de|$)'
        ], vehicle_content),
        
        'Tipo de Carroceria': extract_simple([
            r'Tipo de Carroceria[:\s]*([^\n\r]+?)(?=\s*Isen√ß√£o|$)'
        ], vehicle_content),
        
        'Isen√ß√£o Fiscal': extract_simple([
            r'Isen√ß√£o Fiscal[:\s]*([^\n\r]+?)(?=\s*Propriet√°rio|$)'
        ], vehicle_content),
        
        'Propriet√°rio': extract_simple([
            r'Propriet√°rio[:\s]*([^\n\r]+?)(?=\s*Fipe|$)'
        ], vehicle_content),
        
        'Fipe': extract_simple([
            r'Fipe[:\s]*([^\n\r]+?)(?=\s*Tipo de Seguro|$)'
        ], vehicle_content),
        
        'Tipo de Seguro': extract_simple([
            r'Tipo de Seguro[:\s]*([^\n\r]+?)(?=\s*Nr Ap√≥lice|$)'
        ], vehicle_content),
        
        'Nome da Seguradora Anterior': extract_simple([
            r'Nome da Congenere[:\s]*([^\n\r]+?)(?=\s*Venc Ap√≥lice|$)'
        ], vehicle_content),
        
        'Nr Ap√≥lice Cong√™nere': extract_simple([
            r'Nr Ap√≥lice Congenere[:\s]*([^\n\r]+?)(?=\s*Venc|$)'
        ], vehicle_content),
        
        'Venc Ap√≥lice Cong.': extract_simple([
            r'Venc Ap√≥lice Cong\.[:\s]*([^\n\r]+?)(?=\s*Classe|$)'
        ], vehicle_content),
        
        'Classe de B√¥nus': extract_simple([
            r'Classe de B√¥nus[:\s]*(\d+)'
        ], vehicle_content),
        
        'C√≥digo de Identifica√ß√£o (CI)': extract_simple([
            r'C√≥digo de Identifica√ß√£o \(CI\)[:\s]*([^\n\r]+?)(?=\s*Km de|$)'
        ], vehicle_content),
        
        'Km de Reboque': extract_simple([
            r'Km de Reboque[:\s]*([^\n\r]+?)(?=\s*CNPJ|$)'
        ], vehicle_content),
        
        'CNPJ Fornecedor': extract_simple([
            r'CNPJ[:\s]*([^\n\r]+?)(?=\s*Fornecedor|$)'
        ], vehicle_content),
        
        'Fornecedor de Vidros': extract_simple([
            r'Fornecedor de Vidros[:\s]*([^\n\r]+?)(?=\s*Coberturas|$)'
        ], vehicle_content),
        
        # Pr√™mio L√≠quido Total - campo mais importante
        'Pr√™mio L√≠quido Total': extract_money([
            r'Pr√™mio L√≠quido Total[:\s]*([0-9.,]+)',
            r'Pr√™mio L√≠quido Total.*?(\d+[\d.,]*)',
        ], vehicle_content),
    }
    
    # Extra√ß√£o simplificada de coberturas (valores principais)
    cobertura_patterns = {
        'Limite Colis√£o VMR': r'Valor Referenciado \(VMR\)\s*([0-9.,]+)',
        'Pr√™mio Colis√£o': r'Colis√£o, Inc√™ndio e Roubo.*?([0-9.,]+)(?:\s+[0-9.,]+)?',
        'Limite RCF Danos Materiais': r'RCF-V - Danos Materiais\s+([0-9.,]+)',
        'Pr√™mio RCF Danos Materiais': r'RCF-V - Danos Materiais\s+[0-9.,]+\s+([0-9.,]+)',
        'Limite APP Morte': r'APP - Morte por Passageiro\s+([0-9.,]+)',
        'Pr√™mio APP Morte': r'APP - Morte por Passageiro\s+[0-9.,]+\s+([0-9.,]+)',
    }
    
    for field, pattern in cobertura_patterns.items():
        dados[field] = extract_money([pattern], vehicle_content)
    
    # Franquias principais
    franquia_patterns = {
        'Franquia Parabrisa': r'Parabrisa[:\s]*R\$\s*([0-9.,]+)',
        'Franquia Lateral': r'Lateral[:\s]*R\$\s*([0-9.,]+)',
        'Franquia Farol': r'Farol[^:]*[:\s]*R\$\s*([0-9.,]+)',
        'Franquia Retrovisor': r'Retrovisor[^:]*[:\s]*R\$\s*([0-9.,]+)',
    }
    
    for field, pattern in franquia_patterns.items():
        dados[field] = extract_money([pattern], vehicle_content)
    
    return dados

def parse_header_data(text):
    """Extrai dados gerais da ap√≥lice"""
    dados_header = {
        'Raz√£o Social': extract_field([
            r'Raz√£o Social[:\s]*([^\n\r]+?)(?=\s*CNPJ|$)',
            r'(ROD TRANSPORTES LTDA)'
        ], text),
        
        'CNPJ': extract_field([
            r'CNPJ[:\s]*([^\n\r]+?)(?=\s*Atividade|$)',
            r'(\d{3}\.\d{3}\.\d{3}/\d{4}-\d{2})'
        ], text),
        
        'Atividade Principal': extract_field([
            r'Atividade Principal[:\s]*([^\n\r]+?)(?=\s*Endere√ßo|$)'
        ], text),
        
        'Endere√ßo': extract_field([
            r'Endere√ßo[:\s]*([^\n\r]+?)(?=\s*Bairro|$)'
        ], text),
        
        'Ap√≥lice': extract_field([
            r'Ap√≥lice[:\s]*([^\n\r]+?)(?=\s*Neg√≥cio|$)'
        ], text),
        
        'Vig√™ncia do Seguro': extract_field([
            r'Vig√™ncia do Seguro[:\s]*([^\n\r]+?)(?=\s*Data|$)'
        ], text),
        
        'Pr√™mio Total Geral': extract_field([
            r'Pr√™mio Total[:\s]*R\$\s*([^\n\r]+?)(?=\s*Cobran√ßa|$)'
        ], text),
        
        'Quantidade de Itens': extract_field([
            r'Quantidade de Itens[:\s]*([^\n\r]+?)(?=\s*Sucursal|$)'
        ], text),
    }
    
    return dados_header

def create_excel_file(dados_header, all_vehicles_data):
    """Cria arquivo Excel com os dados extra√≠dos"""
    buffer = BytesIO()
    
    with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
        # Aba com dados gerais da ap√≥lice
        df_header = pd.DataFrame([dados_header])
        df_header.to_excel(writer, sheet_name='Dados Gerais', index=False)
        
        # Aba com todos os ve√≠culos
        if all_vehicles_data:
            df_vehicles = pd.DataFrame(all_vehicles_data)
            df_vehicles.to_excel(writer, sheet_name='Todos os Ve√≠culos', index=False)
            
            # Aba resumo com campos principais
            resumo_columns = [
                'Item', 'Fabricante', 'Ve√≠culo', 'Ano Modelo', 'Placa', 'Chassi',
                'Combust√≠vel', 'Pr√™mio L√≠quido Total', 'Classe de B√¥nus'
            ]
            
            resumo_data = []
            for vehicle in all_vehicles_data:
                resumo_row = {col: vehicle.get(col, '') for col in resumo_columns}
                resumo_data.append(resumo_row)
            
            df_resumo = pd.DataFrame(resumo_data)
            df_resumo.to_excel(writer, sheet_name='Resumo Ve√≠culos', index=False)
    
    buffer.seek(0)
    return buffer

def main():
    st.title("üöó Conversor de Ap√≥lices Tokio Marine")
    st.markdown("---")
    
    # Status do sistema
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.success("‚úÖ PyPDF2 (Texto)")
    with col2:
        if TESSERACT_AVAILABLE:
            st.success("‚úÖ Tesseract (OCR)")
        elif OCR_AVAILABLE:
            st.warning("‚ö†Ô∏è EasyOCR (Lento)")
        else:
            st.error("‚ùå OCR indispon√≠vel")
    with col3:
        st.success("‚úÖ Excel Export")
    
    st.markdown("""
    ### üìã Extra√ß√£o Robusta de Dados:
    
    **‚úÖ M√∫ltiplas estrat√©gias de detec√ß√£o:**
    - Padr√£o "Descri√ß√£o do Item" (preferencial)
    - Detec√ß√£o por CEP de pernoite
    - Detec√ß√£o por fabricantes
    - Detec√ß√£o por placas (fallback)
    
    **üìä Dados extra√≠dos por ve√≠culo:**
    - Identifica√ß√£o completa (CEP, fabricante, modelo, etc.)
    - Valores de coberturas e pr√™mios
    - Franquias principais
    - Classe de b√¥nus e c√≥digos
    """)
    
    # Upload do arquivo
    uploaded_file = st.file_uploader(
        "Escolha um arquivo PDF da ap√≥lice Tokio Marine",
        type=['pdf'],
        help="O sistema tentar√° m√∫ltiplas estrat√©gias para encontrar os ve√≠culos no PDF."
    )
    
    if uploaded_file is not None:
        st.success(f"‚úÖ Arquivo carregado: {uploaded_file.name}")
        st.info(f"üìä Tamanho: {len(uploaded_file.getvalue())/1024:.1f} KB")
        
        if st.button("üîÑ Processar PDF", type="primary"):
            # Extrai texto do PDF
            text = extract_text_from_pdf(uploaded_file)
            
            if text.strip():
                # Parse dos dados gerais
                with st.spinner("üè¢ Analisando dados gerais da ap√≥lice..."):
                    dados_header = parse_header_data(text)
                
                # Parse dos ve√≠culos com estrat√©gias m√∫ltiplas
                st.markdown("### üîç Buscando Ve√≠culos na Ap√≥lice")
                vehicles = extract_vehicle_sections(text)
                
                if vehicles:
                    with st.spinner("üöó Extraindo dados dos ve√≠culos..."):
                        all_vehicles_data = []
                        
                        progress_bar = st.progress(0)
                        status_text = st.empty()
                        
                        for i, vehicle in enumerate(vehicles):
                            progress = (i + 1) / len(vehicles)
                            progress_bar.progress(progress)
                            status_text.text(f"Processando ve√≠culo {vehicle['item']} de {len(vehicles)}...")
                            
                            vehicle_data = parse_vehicle_data(vehicle['content'], vehicle['item'])
                            all_vehicles_data.append(vehicle_data)
                        
                        progress_bar.progress(1.0)
                        status_text.text(f"‚úÖ {len(vehicles)} ve√≠culos processados!")
                        
                        import time
                        time.sleep(1)
                        progress_bar.empty()
                        status_text.empty()
                
                # Mostra resultados
                st.markdown("## üìã Dados Extra√≠dos")
                
                # M√©tricas
                col1, col2, col3 = st.columns(3)
                with col1:
                    campos_header = len([v for v in dados_header.values() if v and v != ""])
                    st.metric("üìÑ Dados Gerais", f"{campos_header}/8")
                with col2:
                    st.metric("üöó Ve√≠culos", len(vehicles))
                with col3:
                    if vehicles and all_vehicles_data:
                        campos_veiculo = len([v for v in all_vehicles_data[0].values() if v and v != ""])
                        st.metric("üìä Campos/Ve√≠culo", f"{campos_veiculo}/35")
                
                # Dados gerais
                st.markdown("### üè¢ Informa√ß√µes da Ap√≥lice")
                for key, value in dados_header.items():
                    if value and value != "":
                        st.success(f"**{key}:** {value}")
                    else:
                        st.warning(f"**{key}:** N√£o encontrado")
                
                # Resumo dos ve√≠culos
                if vehicles and all_vehicles_data:
                    st.markdown("### üöô Ve√≠culos Encontrados")
                    
                    resumo_data = []
                    for vehicle in all_vehicles_data:
                        resumo = {
                            'Item': vehicle.get('Item', ''),
                            'Fabricante': vehicle.get('Fabricante', ''),
                            'Ve√≠culo': vehicle.get('Ve√≠culo', ''),
                            'Ano': vehicle.get('Ano Modelo', ''),
                            'Placa': vehicle.get('Placa', ''),
                            'Pr√™mio Total': vehicle.get('Pr√™mio L√≠quido Total', '')
                        }
                        resumo_data.append(resumo)
                    
                    df_resumo = pd.DataFrame(resumo_data)
                    st.dataframe(df_resumo, use_container_width=True)
                    
                    # Estat√≠sticas por fabricante
                    if 'Fabricante' in df_resumo.columns:
                        fabricantes_count = df_resumo['Fabricante'].value_counts()
                        if len(fabricantes_count) > 0:
                            st.markdown("#### üìä Distribui√ß√£o por Fabricante")
                            st.bar_chart(fabricantes_count)
                
                # Tabelas expandidas
                with st.expander("üìä Ver todos os dados detalhados"):
                    st.markdown("#### Dados Gerais Completos")
                    df_header_display = pd.DataFrame([dados_header])
                    st.dataframe(df_header_display, use_container_width=True)
                    
                    if vehicles and all_vehicles_data:
                        st.markdown("#### Todos os Dados dos Ve√≠culos")
                        df_vehicles_display = pd.DataFrame(all_vehicles_data)
                        st.dataframe(df_vehicles_display, use_container_width=True)
                        
                        # An√°lise de completude dos dados
                        st.markdown("#### üéØ An√°lise de Completude dos Dados")
                        
                        # Calcular estat√≠sticas de completude
                        total_campos = len(df_vehicles_display.columns)
                        completude_por_veiculo = []
                        
                        for index, row in df_vehicles_display.iterrows():
                            campos_preenchidos = sum(1 for val in row if val and str(val).strip() and str(val) != '')
                            percentual = (campos_preenchidos / total_campos) * 100
                            completude_por_veiculo.append({
                                'Ve√≠culo': f"Item {row.get('Item', index+1)}",
                                'Campos Preenchidos': f"{campos_preenchidos}/{total_campos}",
                                'Percentual': f"{percentual:.1f}%"
                            })
                        
                        df_completude = pd.DataFrame(completude_por_veiculo)
                        st.dataframe(df_completude, use_container_width=True)
                
                # Gera o arquivo Excel
                if vehicles and all_vehicles_data:
                    with st.spinner("üìä Gerando arquivo Excel..."):
                        excel_buffer = create_excel_file(dados_header, all_vehicles_data)
                    
                    # Se√ß√£o de download
                    st.markdown("## üíæ Download")
                    
                    apolice_numero = dados_header.get('Ap√≥lice', '')
                    if not apolice_numero or apolice_numero.strip() == "":
                        apolice_numero = "sem_numero"
                    nome_arquivo = f"tokio_marine_apolice_{apolice_numero}.xlsx"
                    
                    col1, col2 = st.columns([2, 1])
                    
                    with col1:
                        st.download_button(
                            label="üì• Baixar Planilha Excel Completa",
                            data=excel_buffer,
                            file_name=nome_arquivo,
                            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                            type="primary"
                        )
                    
                    with col2:
                        st.info(f"""
                        **üìã Arquivo Excel cont√©m:**
                        - üìÑ Dados Gerais da Ap√≥lice
                        - üöó Todos os Ve√≠culos ({len(vehicles)} itens)
                        - üìä Resumo dos Ve√≠culos
                        """)
                    
                    # Sucesso final
                    taxa_deteccao = len(vehicles)
                    if taxa_deteccao > 20:
                        st.balloons()
                        st.success(f"üéâ Excelente! {taxa_deteccao} ve√≠culos detectados e processados com sucesso!")
                    elif taxa_deteccao > 10:
                        st.success(f"‚úÖ Muito bom! {taxa_deteccao} ve√≠culos detectados e processados!")
                    elif taxa_deteccao > 0:
                        st.success(f"‚úÖ {taxa_deteccao} ve√≠culos detectados e processados!")
                    else:
                        st.warning("‚ö†Ô∏è Nenhum ve√≠culo detectado. Verifique se √© uma ap√≥lice Tokio Marine Auto Frota.")
                        
                else:
                    st.warning("‚ö†Ô∏è Nenhum ve√≠culo foi encontrado no PDF.")
                    st.info("üí° Isso pode acontecer se:")
                    st.markdown("""
                    - O PDF n√£o √© uma ap√≥lice Tokio Marine Auto Frota
                    - O formato do PDF √© muito diferente do esperado
                    - A qualidade do OCR (se usado) foi insuficiente
                    - O arquivo est√° corrompido ou protegido
                    """)
                
            else:
                st.error("‚ùå N√£o foi poss√≠vel extrair texto do PDF.")
                st.info("üí° Poss√≠veis causas:")
                st.markdown("""
                - PDF protegido ou criptografado
                - PDF corrompido
                - OCR n√£o dispon√≠vel para PDFs de imagem
                - Formato de arquivo n√£o suportado
                """)
        
        # Debug - Se√ß√£o expand√≠vel para an√°lise do texto
        with st.expander("üîç Debug: Ver texto extra√≠do e an√°lise detalhada"):
            if st.button("üîç Extrair e Analisar Texto"):
                with st.spinner("Extraindo texto para an√°lise..."):
                    debug_text = extract_text_from_pdf(uploaded_file)
                
                if debug_text:
                    # Estat√≠sticas do texto
                    st.markdown("#### üìä Estat√≠sticas do Texto Extra√≠do")
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("Caracteres", f"{len(debug_text):,}")
                    with col2:
                        palavras = len(debug_text.split())
                        st.metric("Palavras", f"{palavras:,}")
                    with col3:
                        linhas = len(debug_text.split('\n'))
                        st.metric("Linhas", f"{linhas:,}")
                    with col4:
                        # Conta men√ß√µes de "Descri√ß√£o do Item"
                        mencoes_item = len(re.findall(r'Descri√ß√£o do Item', debug_text, re.IGNORECASE))
                        st.metric("'Descri√ß√£o do Item'", mencoes_item)
                    
                    # Busca por padr√µes espec√≠ficos
                    st.markdown("#### üîç Padr√µes Encontrados")
                    
                    patterns_debug = {
                        "CEPs encontrados": r'\d{5}-?\d{3}',
                        "Placas encontradas": r'[A-Z]{3}\d{4}|[A-Z]{3}\d[A-Z]\d{2}',
                        "Fabricantes encontrados": r'(CHEVROLET|FORD|VOLKSWAGEN|FIAT|NISSAN|TOYOTA|BYD|MITSUBISHI)',
                        "Valores R$ encontrados": r'R\$\s*[\d.,]+',
                        "Anos encontrados": r'\b(19|20)\d{2}\b'
                    }
                    
                    for desc, pattern in patterns_debug.items():
                        matches = re.findall(pattern, debug_text, re.IGNORECASE)
                        if matches:
                            st.success(f"**{desc}:** {len(matches)} - Exemplos: {', '.join(matches[:5])}")
                        else:
                            st.warning(f"**{desc}:** Nenhum encontrado")
                    
                    # Tenta detectar ve√≠culos com debug
                    st.markdown("#### üöó Debug: Detec√ß√£o de Ve√≠culos")
                    debug_vehicles = extract_vehicle_sections(debug_text)
                    
                    if debug_vehicles:
                        st.success(f"‚úÖ {len(debug_vehicles)} se√ß√µes de ve√≠culos detectadas!")
                        
                        # Mostra primeiras se√ß√µes encontradas
                        for i, vehicle in enumerate(debug_vehicles[:3]):
                            st.markdown(f"**üöó Ve√≠culo {vehicle['item']}:**")
                            content_preview = vehicle['content'][:800] + "..." if len(vehicle['content']) > 800 else vehicle['content']
                            st.text_area(
                                f"Conte√∫do do Item {vehicle['item']}:", 
                                content_preview, 
                                height=200,
                                key=f"debug_vehicle_{i}"
                            )
                        
                        if len(debug_vehicles) > 3:
                            st.info(f"... e mais {len(debug_vehicles) - 3} ve√≠culos detectados.")
                    
                    # Amostra do texto completo
                    st.markdown("#### üìù Amostra do Texto Completo")
                    texto_amostra = debug_text[:5000] + "\n\n... (texto truncado)" if len(debug_text) > 5000 else debug_text
                    st.text_area(
                        "Texto extra√≠do completo:", 
                        texto_amostra, 
                        height=300
                    )
                    
                else:
                    st.error("‚ùå N√£o foi poss√≠vel extrair texto para debug")

    # Sidebar com informa√ß√µes t√©cnicas
    with st.sidebar:
        st.markdown("## üõ†Ô∏è Informa√ß√µes T√©cnicas")
        
        st.markdown("### üìã Estrat√©gias de Detec√ß√£o")
        st.markdown("""
        **1. Padr√£o Principal:** "Descri√ß√£o do Item"
        **2. Fallback CEP:** CEP de pernoite  
        **3. Fallback Fabricante:** Marcas conhecidas
        **4. Fallback Placa:** Padr√µes de placas
        """)
        
        st.markdown("### üîß Configura√ß√£o OCR")
        st.markdown("**Para Streamlit Cloud:**")
        
        st.code("""# packages.txt
tesseract-ocr
tesseract-ocr-por
poppler-utils""", language="text")
        
        st.code("""# requirements.txt
streamlit
PyPDF2
pandas
openpyxl
pytesseract
pdf2image
Pillow
numpy""", language="text")
        
        st.markdown("### üìä Campos Extra√≠dos")
        st.markdown("""
        **Por ve√≠culo:**
        - üÜî Identifica√ß√£o (15+ campos)
        - üí∞ Coberturas (10+ campos)  
        - üîß Franquias (10+ campos)
        
        **Total:** ~35 campos/ve√≠culo
        """)
        
        st.markdown("### üí° Dicas de Uso")
        st.markdown("""
        - ‚ö° PDFs nativos: Processamento instant√¢neo
        - üì∏ PDFs escaneados: Requer OCR (mais lento)
        - üîç Use o debug se n√£o encontrar ve√≠culos
        - üìä Resultado em m√∫ltiplas abas Excel
        - üéØ Sistema detecta automaticamente o formato
        """)
        
        st.markdown("### üìû Suporte")
        st.markdown("""
        Se n√£o conseguir extrair os dados:
        1. Verifique se √© uma ap√≥lice Tokio Marine
        2. Use a fun√ß√£o de debug
        3. Teste com PDF de melhor qualidade
        4. Verifique se o OCR est√° funcionando
        """)

if __name__ == "__main__":
    main()